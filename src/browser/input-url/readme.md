# 从输入 URL 到页面展示

## 1. 用户输入

- 搜索内容，使用默认的搜索引擎合成新的带搜索关键字的 URL
- 输入内容符合 URL 规则

触发当前页面的 `beforeunload` 事件，标签页显示加载状态。

## 2. URL 请求过程

浏览器进程通过 IPC 把 URL 发送至网络进程：网络进程首先查找本地缓存，若有直接返回给浏览器进程；无缓存进入网络请求流程，DNS 解析获取域名服务器 IP，协议若为 HTTPS，还需建立 TLS 连接。

与服务器建立 TCP 连接，浏览器端构建请求报文（行、头、体），并将和该域名相关的 Cookie 等数据附加到请求头，向服务器发送构建的请求报文。

服务器收到请求，生成响应报文（行、头、体）发送给网络进程。

### 2.1 重定向

若响应状态码 301（永久重定向）、302（暂时性转移）等，网络进程从 `Location` 字段读取重定向地址，再次发起新请求。

例如：网站会把所有的 HTTP 请求重定向到 HTTPS。

### 2.2 响应数据类型处理

根据 `Content-Type` 进行下一步处理，这里假定为 `Content-Type: text/html`。

## 3. 准备渲染进程

- 打开新页面使用单独的渲染进程；
- 从 A 页面打开 B 页面，如果 A B 属于同一站点（**协议**和**根域名**相同），B 页面将复用 A 页面的渲染进程；否则，为 B 创建新的渲染进程。

## 4. 提交文档

- 浏览器进程收到网络进程的响应数据，向渲染进程发起 `提交文档` 的消息；
- 渲染进程收到消息后，和网络进程建立传输数据的管道；
- 文档数据传输完成后，渲染进程返回 `确认提交` 的消息给浏览器进程；
- 浏览器进程收到消息后，更新浏览器界面的状态：安全状态、地址栏 URL、前进后退的历史状态，并更新 Web 页面。

## 5. 渲染阶段

### 5.1 构建 DOM 树

### 5.2 样式计算

CSS 文本转换为 styleSheets（`document.styleSheets`）。

将样式表中的属性值标准化：
![](./img/css1.webp)

计算 DOM 树中每个节点的具体样式，遵守 CSS 的继承和层叠两个规则。

### 5.3 布局阶段

#### 创建布局树

遍历 DOM 树中的所有**可见节点**，将其加到布局树中。不可见节点会被布局树忽略掉。

#### 布局计算

计算每个元素的具体几何位置。

### 5.4 分层

渲染引擎需要为特定的节点生成专用图层，并生成一棵对应的图层树。如果一个节点没有对应的层，那么这个节点从属于父节点的图层。

- 拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)属性的元素会被提升为单独一层。
- 需要剪裁（clip）的地方会被创建为图层。例如，文字溢出容器，文字会被单独创建一个层，出现滚动条，滚动条也会提升为单独的层。

### 5.5 图层绘制

将绘制指令按照顺序组成一个待绘制列表。

![](./img/draw-table.webp)


### 5.6 栅格化（raster）操作

主线程把绘制列表提交给合成线程。合成线程将图层划分为图块（tile），按照视口（viewpoint）附近的图块优先生成位图，即栅格化。此过程实际在 GPU 中执行完成，由 GPU 加速又叫快速栅格化。

![](./img/raster.webp)

### 5.7 合成和显示

所有图块栅格化完毕 → 提交 `DrawQuad` 命令 → 浏览器进程 viz 组件 → 页面内容绘制到内存 → 内存数据显示在屏幕上

![完整渲染流程](./img/full-render-flow.webp)


当页面生成完成，渲染进程会发送消息给浏览器进程，浏览器进程收到消息后，停止标签图标上的加载动画。

## FAQ

### 1、CSS 会阻塞 DOM 解析吗？

CSS 通过外部地址引入，当 JS 脚本访问了某个元素的样式时，就需要等待 CSS 下载完成才能继续往下执行，这种情况 CSS 会阻塞 DOM 的解析。

### 2、CSS 会阻塞 JS 吗？

只要页面有样式和 script 标签，那么 JS 就会等待 CSS 解析完成后再执行（包括文件下载和文件解析）。因为浏览器无法确定 JS 中是否操作了样式。

### 3、重排：更新了元素的几何属性

![](./img/reflow.webp)

重排需要更新完整的渲染流水线，故开销最大。

### 4、重绘：更新了元素的绘制属性

![](./img/repaint.webp)

无需布局和分层，执行效率略高于重排。

### 5、直接合成

![](./img/compose.webp)

直接在合成线程上执行，不占用主线程资源，故效率最高。

### 6、如何减少重排重绘？

1. 使用 class 集中定义样式，而不是频繁操作 style；
2. 避免使用 table 布局；
3. 批量 DOM 操作，如 [DocumentFragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment)；
4. debounce resize 事件；
5. DOM 属性读写分离。读取/修改操作放在一起执行，不要取一下值，改一下值；
6. 设置 `will-change` 优化动画。
