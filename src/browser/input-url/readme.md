# 从输入 URL 到页面展示

## 1. 用户输入

- 搜索内容，使用默认的搜索引擎合成新的带搜索关键字的 URL
- 输入内容符合 URL 规则

触发当前页面的 `beforeunload` 事件，标签页显示加载状态。

## 2. URL 请求过程

浏览器进程通过 IPC 把 URL 发送至网络进程：网络进程首先查找本地缓存，若有直接返回给浏览器进程；无缓存进入网络请求流程，DNS 解析获取域名服务器 IP，协议若为 HTTPS，还需建立 TLS 连接。

与服务器建立 TCP 连接，浏览器端构建请求报文（行、头、体），并将和该域名相关的 Cookie 等数据附加到请求头，向服务器发送构建的请求报文。

服务器收到请求，生成响应报文（行、头、体）发送给网络进程。

### 2.1 重定向

若响应状态码 301（永久重定向）、302（暂时性转移）等，网络进程从 `Location` 字段读取重定向地址，再次发起新请求。

例如：网站会把所有的 HTTP 请求重定向到 HTTPS。

### 2.2 响应数据类型处理

根据 `Content-Type` 进行下一步处理，这里假定为 `Content-Type: text/html`。

## 3. 准备渲染进程

- 打开新页面使用单独的渲染进程；
- 从 A 页面打开 B 页面，如果 A B 属于同一站点（**协议**和**根域名**相同），B 页面将复用 A 页面的渲染进程；否则，为 B 创建新的渲染进程。

## 4. 提交文档

- 浏览器进程收到网络进程的响应数据，向渲染进程发起 `提交文档` 的消息；
- 渲染进程收到消息后，和网络进程建立传输数据的管道；
- 文档数据传输完成后，渲染进程返回 `确认提交` 的消息给浏览器进程；
- 浏览器进程收到消息后，更新浏览器界面的状态：安全状态、地址栏 URL、前进后退的历史状态，并更新 Web 页面。

## 5. 渲染阶段

### 5.1 构建 DOM 树

### 5.2 样式计算

CSS 文本转换为 styleSheets（`document.styleSheets`）。

将样式表中的属性值标准化：
![](./img/css1.webp)

计算 DOM 树中每个节点的具体样式，遵守 CSS 的继承和层叠两个规则。

### 5.3 布局阶段

#### 创建布局树

遍历 DOM 树中的所有**可见节点**，将其加到布局树中。不可见节点会被布局树忽略掉。

#### 布局计算

计算每个元素的具体几何位置。

### 5.4 分层

渲染引擎需要为特定的节点生成专用图层，并生成一棵对应的图层树。如果一个节点没有对应的层，那么这个节点从属于父节点的图层。

- 拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)属性的元素会被提升为单独一层。
- 需要剪裁（clip）的地方会被创建为图层。例如，文字溢出容器，文字会被单独创建一个层，出现滚动条，滚动条也会提升为单独的层。

### 5.5 图层绘制

将绘制指令按照顺序组成一个待绘制列表。

![](./img/draw-table.webp)


### 5.6 栅格化（raster）操作

主线程把绘制列表提交给合成线程。合成线程将图层划分为图块（tile），按照视口（viewpoint）附近的图块优先生成位图，即栅格化。此过程实际在 GPU 中执行完成，由 GPU 加速又叫快速栅格化。

![](./img/raster.webp)

### 5.7 合成和显示

所有图块栅格化完毕 → 提交 `DrawQuad` 命令 → 浏览器进程 viz 组件 → 页面内容绘制到内存 → 内存数据显示在屏幕上

![完整渲染流程](./img/full-render-flow.webp)


当页面生成完成，渲染进程会发送消息给浏览器进程，浏览器进程收到消息后，停止标签图标上的加载动画。

## FAQ

### 1、CSS 会阻塞 DOM 解析吗？

CSS 通过外部地址引入，当 JS 脚本访问了某个元素的样式时，就需要等待 CSS 下载完成才能继续往下执行，这种情况 CSS 会阻塞 DOM 的解析。

### 2、CSS 会阻塞 JS 吗？

只要页面有样式和 script 标签，那么 JS 就会等待 CSS 解析完成后再执行（包括文件下载和文件解析）。因为浏览器无法确定 JS 中是否操作了样式。

### 3、重排：更新了元素的几何属性

![](./img/reflow.webp)

重排需要更新完整的渲染流水线，故开销最大。

### 4、重绘：更新了元素的绘制属性

![](./img/repaint.webp)

无需布局和分层，执行效率略高于重排。

### 5、直接合成

![](./img/compose.webp)

直接在合成线程上执行，不占用主线程资源，故效率最高。

### 6、如何减少重排重绘？

1. 使用 class 集中定义样式，而不是频繁操作 style；
2. 避免使用 table 布局；
3. 批量 DOM 操作，如 [DocumentFragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment)；
4. debounce resize 事件；
5. DOM 属性读写分离。读取/修改操作放在一起执行，不要取一下值，改一下值；
6. 设置 [will-change](https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change) 预先创建单独图层。正确做法应为动画开始前设置，结束后移除；
7. 动画中设置 `transform`、`opacity`、`filter` 等会为元素单独创建一层。`translate3d` 无论是否在动画中，均会单独创建一层。

## 总结流程

1. 用户输入 url 并回车。
2. 浏览器进程检查 url，组装协议，构成完整的 url。
3. 浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程。
4. 网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程。
5. 如果没有，网络进程向 Web 服务器发起 http 请求（网络请求）
    1. 进行 DNS 解析，获取服务器 ip 地址
    2. 利用 ip 地址和服务器建立 tcp 连接
    3. 构建并发送请求报文
    4. 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
6. 网络进程解析响应流程
    1. 检查状态码，如果是 301/302，则需要重定向，从 `Location` 中读取地址，重新进行第4步，如果是 200，则继续处理请求。
    2. 200 响应处理：
        检查响应类型 `Content-Type`，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。
7. 准备渲染进程
    1. 浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
8. 传输数据、更新状态
    1. 渲染进程准备好后，浏览器向渲染进程发起`提交文档`的消息，渲染进程接收到消息和网络进程建立传输数据的`管道`
    2. 渲染进程接收完数据后，向浏览器发送`确认提交`
    3. 浏览器进程接收到确认消息后更新浏览器界面状态：安全状态、地址栏 url、前进后退的历史状态、更新页面。
9. 完整渲染流程：
    1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
    2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
    3. 创建布局树，并计算元素的布局信息。
    4. 对布局树进行分层，并生成分层树。
    5. 为每个图层生成绘制列表，并将其提交到合成线程。
    6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
    7. 合成线程发送绘制图块命令 `DrawQuad` 给浏览器进程。
    8. 浏览器进程根据 `DrawQuad` 消息生成页面，并显示到显示器上。
